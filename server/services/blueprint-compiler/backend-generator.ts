/**
 * Backend Generator - مولّد الباك إند
 * 
 * Generates Express.js backend code from Blueprint specifications.
 * Produces routes, controllers, services, and middleware.
 */

import {
  Blueprint,
  BackendSpec,
  DataModelSpec,
  EntityDefinition,
  EndpointDefinition,
  ServiceDefinition,
  AuthSpec,
  GeneratedFile
} from './types';

export class BackendGenerator {
  
  /**
   * Generate all backend files from a Blueprint
   */
  generateBackendFiles(blueprint: Blueprint): GeneratedFile[] {
    const files: GeneratedFile[] = [];
    const { backend, dataModel, auth } = blueprint;
    
    // Generate main routes file
    files.push(this.generateRoutesFile(backend, dataModel, blueprint.id));
    
    // Generate controllers for each entity
    for (const entity of dataModel.entities) {
      files.push(this.generateController(entity, blueprint.id));
    }
    
    // Generate services
    for (const entity of dataModel.entities) {
      files.push(this.generateService(entity, blueprint.id));
    }
    
    // Generate auth middleware
    files.push(this.generateAuthMiddleware(auth, blueprint.id));
    
    // Generate validation middleware
    files.push(this.generateValidationMiddleware(dataModel, blueprint.id));
    
    // Generate storage interface
    files.push(this.generateStorageInterface(dataModel, blueprint.id));
    
    console.log(`[BackendGenerator] Generated ${files.length} backend files for blueprint ${blueprint.id}`);
    
    return files;
  }
  
  /**
   * Generate main routes file
   */
  private generateRoutesFile(
    backend: BackendSpec,
    dataModel: DataModelSpec,
    blueprintId: string
  ): GeneratedFile {
    const entityImports = dataModel.entities.map(e => 
      `import { ${e.name.toLowerCase()}Controller } from './controllers/${e.name.toLowerCase()}-controller';`
    ).join('\n');
    
    const routeRegistrations = dataModel.entities.map(e => {
      const basePath = `/${e.tableName.replace(/_/g, '-')}`;
      return `  // ${e.nameAr} routes
  app.get('${basePath}', requireAuth, ${e.name.toLowerCase()}Controller.list);
  app.get('${basePath}/:id', requireAuth, ${e.name.toLowerCase()}Controller.get);
  app.post('${basePath}', requireAuth, validate(insert${e.name}Schema), ${e.name.toLowerCase()}Controller.create);
  app.put('${basePath}/:id', requireAuth, validate(insert${e.name}Schema.partial()), ${e.name.toLowerCase()}Controller.update);
  app.delete('${basePath}/:id', requireAuth, ${e.name.toLowerCase()}Controller.delete);`;
    }).join('\n\n');
    
    const schemaImports = dataModel.entities.map(e => `insert${e.name}Schema`).join(', ');
    
    const content = `/**
 * API Routes - Generated by Blueprint Compiler
 * Blueprint ID: ${blueprintId}
 * Generated: ${new Date().toISOString()}
 */

import type { Express, Request, Response, NextFunction } from 'express';
import { requireAuth } from './middleware/auth';
import { validate } from './middleware/validation';
import { ${schemaImports} } from '@shared/types';
${entityImports}

export function registerRoutes(app: Express): void {
  // Health check
  app.get('/api/health', (_req: Request, res: Response) => {
    res.json({ status: 'healthy', timestamp: new Date().toISOString() });
  });

${routeRegistrations}

  // 404 handler for API routes
  app.use('/api/*', (_req: Request, res: Response) => {
    res.status(404).json({ error: 'Not found' });
  });
}
`;
    
    return {
      path: `generated/${blueprintId}/server/routes.ts`,
      content,
      type: 'typescript',
      checksum: this.generateChecksum(content),
      generatedAt: new Date()
    };
  }
  
  /**
   * Generate controller for an entity
   */
  private generateController(entity: EntityDefinition, blueprintId: string): GeneratedFile {
    const name = entity.name;
    const serviceName = `${name.toLowerCase()}Service`;
    
    const content = `/**
 * ${name} Controller - ${entity.nameAr}
 * Generated by Blueprint Compiler
 * Blueprint ID: ${blueprintId}
 */

import type { Request, Response } from 'express';
import { ${serviceName} } from '../services/${name.toLowerCase()}-service';

export const ${name.toLowerCase()}Controller = {
  /**
   * List all ${name} records
   */
  async list(req: Request, res: Response): Promise<void> {
    try {
      const page = parseInt(req.query.page as string) || 1;
      const limit = parseInt(req.query.limit as string) || 20;
      const offset = (page - 1) * limit;
      
      const { data, total } = await ${serviceName}.findAll({ limit, offset });
      
      res.json({
        success: true,
        data,
        pagination: {
          page,
          limit,
          total,
          pages: Math.ceil(total / limit)
        }
      });
    } catch (error: any) {
      console.error('[${name}Controller] List error:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  },
  
  /**
   * Get ${name} by ID
   */
  async get(req: Request, res: Response): Promise<void> {
    try {
      const { id } = req.params;
      const record = await ${serviceName}.findById(id);
      
      if (!record) {
        res.status(404).json({ success: false, error: 'Not found' });
        return;
      }
      
      res.json({ success: true, data: record });
    } catch (error: any) {
      console.error('[${name}Controller] Get error:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  },
  
  /**
   * Create new ${name}
   */
  async create(req: Request, res: Response): Promise<void> {
    try {
      const data = req.body;
      const record = await ${serviceName}.create(data);
      
      res.status(201).json({ success: true, data: record });
    } catch (error: any) {
      console.error('[${name}Controller] Create error:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  },
  
  /**
   * Update ${name}
   */
  async update(req: Request, res: Response): Promise<void> {
    try {
      const { id } = req.params;
      const data = req.body;
      const record = await ${serviceName}.update(id, data);
      
      if (!record) {
        res.status(404).json({ success: false, error: 'Not found' });
        return;
      }
      
      res.json({ success: true, data: record });
    } catch (error: any) {
      console.error('[${name}Controller] Update error:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  },
  
  /**
   * Delete ${name}
   */
  async delete(req: Request, res: Response): Promise<void> {
    try {
      const { id } = req.params;
      const success = await ${serviceName}.delete(id);
      
      if (!success) {
        res.status(404).json({ success: false, error: 'Not found' });
        return;
      }
      
      res.json({ success: true, message: 'Deleted successfully' });
    } catch (error: any) {
      console.error('[${name}Controller] Delete error:', error);
      res.status(500).json({ success: false, error: error.message });
    }
  }
};
`;
    
    return {
      path: `generated/${blueprintId}/server/controllers/${name.toLowerCase()}-controller.ts`,
      content,
      type: 'typescript',
      checksum: this.generateChecksum(content),
      generatedAt: new Date()
    };
  }
  
  /**
   * Generate service for an entity
   */
  private generateService(entity: EntityDefinition, blueprintId: string): GeneratedFile {
    const name = entity.name;
    const tableName = this.toCamelCase(entity.tableName);
    
    const content = `/**
 * ${name} Service - ${entity.nameAr}
 * Generated by Blueprint Compiler
 * Blueprint ID: ${blueprintId}
 */

import { eq } from 'drizzle-orm';
import { db } from '../db';
import { ${tableName} } from '@shared/schema';
import type { ${name}, Insert${name} } from '@shared/types';

interface FindAllOptions {
  limit?: number;
  offset?: number;
  tenantId?: string;
}

export const ${name.toLowerCase()}Service = {
  /**
   * Find all ${name} records
   */
  async findAll(options: FindAllOptions = {}): Promise<{ data: ${name}[]; total: number }> {
    const { limit = 20, offset = 0 } = options;
    
    const data = await db
      .select()
      .from(${tableName})
      .limit(limit)
      .offset(offset);
    
    const countResult = await db
      .select()
      .from(${tableName});
    
    return { data, total: countResult.length };
  },
  
  /**
   * Find ${name} by ID
   */
  async findById(id: string): Promise<${name} | null> {
    const [record] = await db
      .select()
      .from(${tableName})
      .where(eq(${tableName}.id, id))
      .limit(1);
    
    return record || null;
  },
  
  /**
   * Create new ${name}
   */
  async create(data: Insert${name}): Promise<${name}> {
    const id = \`\${Date.now()}-\${Math.random().toString(36).substr(2, 9)}\`;
    
    const [record] = await db
      .insert(${tableName})
      .values({ ...data, id })
      .returning();
    
    return record;
  },
  
  /**
   * Update ${name}
   */
  async update(id: string, data: Partial<Insert${name}>): Promise<${name} | null> {
    const [record] = await db
      .update(${tableName})
      .set({ ...data, updatedAt: new Date() })
      .where(eq(${tableName}.id, id))
      .returning();
    
    return record || null;
  },
  
  /**
   * Delete ${name}
   */
  async delete(id: string): Promise<boolean> {
    const result = await db
      .delete(${tableName})
      .where(eq(${tableName}.id, id));
    
    return true;
  }
};
`;
    
    return {
      path: `generated/${blueprintId}/server/services/${name.toLowerCase()}-service.ts`,
      content,
      type: 'typescript',
      checksum: this.generateChecksum(content),
      generatedAt: new Date()
    };
  }
  
  /**
   * Generate auth middleware
   */
  private generateAuthMiddleware(auth: AuthSpec, blueprintId: string): GeneratedFile {
    const content = `/**
 * Authentication Middleware
 * Generated by Blueprint Compiler
 * Blueprint ID: ${blueprintId}
 */

import type { Request, Response, NextFunction } from 'express';

declare module 'express-session' {
  interface SessionData {
    userId: string;
    role: string;
    tenantId?: string;
  }
}

/**
 * Require authentication
 */
export function requireAuth(req: Request, res: Response, next: NextFunction): void {
  if (!req.session?.userId) {
    res.status(401).json({ 
      success: false, 
      error: 'Authentication required',
      errorAr: 'يجب تسجيل الدخول'
    });
    return;
  }
  
  next();
}

/**
 * Require specific role
 */
export function requireRole(...roles: string[]) {
  return (req: Request, res: Response, next: NextFunction): void => {
    if (!req.session?.userId) {
      res.status(401).json({ 
        success: false, 
        error: 'Authentication required' 
      });
      return;
    }
    
    if (!roles.includes(req.session.role)) {
      res.status(403).json({ 
        success: false, 
        error: 'Insufficient permissions',
        errorAr: 'صلاحيات غير كافية'
      });
      return;
    }
    
    next();
  };
}

/**
 * Check permission
 */
export function requirePermission(permission: string) {
  return (req: Request, res: Response, next: NextFunction): void => {
    if (!req.session?.userId) {
      res.status(401).json({ success: false, error: 'Authentication required' });
      return;
    }
    
    // TODO: Implement permission checking against user's role
    next();
  };
}
`;
    
    return {
      path: `generated/${blueprintId}/server/middleware/auth.ts`,
      content,
      type: 'typescript',
      checksum: this.generateChecksum(content),
      generatedAt: new Date()
    };
  }
  
  /**
   * Generate validation middleware
   */
  private generateValidationMiddleware(dataModel: DataModelSpec, blueprintId: string): GeneratedFile {
    const content = `/**
 * Validation Middleware
 * Generated by Blueprint Compiler
 * Blueprint ID: ${blueprintId}
 */

import type { Request, Response, NextFunction } from 'express';
import { ZodSchema, ZodError } from 'zod';

/**
 * Validate request body against a Zod schema
 */
export function validate(schema: ZodSchema) {
  return (req: Request, res: Response, next: NextFunction): void => {
    try {
      const validated = schema.parse(req.body);
      req.body = validated;
      next();
    } catch (error) {
      if (error instanceof ZodError) {
        const errors = error.errors.map(e => ({
          field: e.path.join('.'),
          message: e.message
        }));
        
        res.status(400).json({
          success: false,
          error: 'Validation failed',
          errorAr: 'فشل التحقق من البيانات',
          details: errors
        });
        return;
      }
      
      res.status(500).json({ success: false, error: 'Validation error' });
    }
  };
}

/**
 * Validate query parameters
 */
export function validateQuery(schema: ZodSchema) {
  return (req: Request, res: Response, next: NextFunction): void => {
    try {
      const validated = schema.parse(req.query);
      req.query = validated;
      next();
    } catch (error) {
      if (error instanceof ZodError) {
        res.status(400).json({
          success: false,
          error: 'Invalid query parameters',
          details: error.errors
        });
        return;
      }
      
      res.status(500).json({ success: false, error: 'Validation error' });
    }
  };
}
`;
    
    return {
      path: `generated/${blueprintId}/server/middleware/validation.ts`,
      content,
      type: 'typescript',
      checksum: this.generateChecksum(content),
      generatedAt: new Date()
    };
  }
  
  /**
   * Generate storage interface
   */
  private generateStorageInterface(dataModel: DataModelSpec, blueprintId: string): GeneratedFile {
    const interfaces = dataModel.entities.map(e => {
      const name = e.name;
      return `  // ${e.nameAr}
  ${name.toLowerCase()}: {
    findAll(options?: { limit?: number; offset?: number }): Promise<{ data: ${name}[]; total: number }>;
    findById(id: string): Promise<${name} | null>;
    create(data: Insert${name}): Promise<${name}>;
    update(id: string, data: Partial<Insert${name}>): Promise<${name} | null>;
    delete(id: string): Promise<boolean>;
  };`;
    }).join('\n\n');
    
    const typeImports = dataModel.entities.map(e => `${e.name}, Insert${e.name}`).join(', ');
    
    const content = `/**
 * Storage Interface
 * Generated by Blueprint Compiler
 * Blueprint ID: ${blueprintId}
 */

import type { ${typeImports} } from '@shared/types';

export interface IStorage {
${interfaces}
}
`;
    
    return {
      path: `generated/${blueprintId}/server/storage.ts`,
      content,
      type: 'typescript',
      checksum: this.generateChecksum(content),
      generatedAt: new Date()
    };
  }
  
  /**
   * Convert string to camelCase
   */
  private toCamelCase(str: string): string {
    return str.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());
  }
  
  /**
   * Generate simple checksum
   */
  private generateChecksum(content: string): string {
    let hash = 0;
    for (let i = 0; i < content.length; i++) {
      const char = content.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return Math.abs(hash).toString(16);
  }
}

export const backendGenerator = new BackendGenerator();
