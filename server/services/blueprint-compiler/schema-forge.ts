/**
 * Schema Forge - مصنع المخططات
 * 
 * Generates Drizzle ORM schemas from Blueprint data model specifications.
 * Produces complete TypeScript files with tables, relations, insert schemas, and types.
 */

import {
  Blueprint,
  DataModelSpec,
  EntityDefinition,
  FieldDefinition,
  RelationshipDefinition,
  EnumDefinition,
  GeneratedFile
} from './types';

export class SchemaForge {
  
  /**
   * Generate all schema files from a Blueprint
   */
  generateSchemaFiles(blueprint: Blueprint): GeneratedFile[] {
    const files: GeneratedFile[] = [];
    const { dataModel } = blueprint;
    
    // Generate main schema file
    files.push(this.generateMainSchema(dataModel, blueprint.id));
    
    // Generate insert schemas and types
    files.push(this.generateTypesFile(dataModel, blueprint.id));
    
    // Generate relations file if there are relationships
    if (dataModel.relationships.length > 0) {
      files.push(this.generateRelationsFile(dataModel, blueprint.id));
    }
    
    // Generate migration file
    files.push(this.generateMigrationFile(dataModel, blueprint.id));
    
    console.log(`[SchemaForge] Generated ${files.length} schema files for blueprint ${blueprint.id}`);
    
    return files;
  }
  
  /**
   * Generate main schema.ts file
   */
  private generateMainSchema(dataModel: DataModelSpec, blueprintId: string): GeneratedFile {
    const imports = this.generateImports(dataModel);
    const enums = this.generateEnums(dataModel.enums);
    const tables = dataModel.entities.map(e => this.generateTable(e)).join('\n\n');
    
    const content = `/**
 * Database Schema - Generated by Blueprint Compiler
 * Blueprint ID: ${blueprintId}
 * Generated: ${new Date().toISOString()}
 * 
 * DO NOT EDIT - Changes will be overwritten on regeneration
 */

${imports}

${enums}

${tables}
`;
    
    return {
      path: `generated/${blueprintId}/shared/schema.ts`,
      content,
      type: 'typescript',
      checksum: this.generateChecksum(content),
      generatedAt: new Date()
    };
  }
  
  /**
   * Generate imports based on field types used
   */
  private generateImports(dataModel: DataModelSpec): string {
    const pgTypes = new Set<string>();
    const drizzleTypes = new Set(['pgTable']);
    
    for (const entity of dataModel.entities) {
      for (const field of entity.fields) {
        const pgType = this.fieldTypeToPgType(field.type);
        pgTypes.add(pgType);
        
        if (field.indexed || field.unique) {
          drizzleTypes.add('index');
        }
      }
      
      if (entity.timestamps) {
        pgTypes.add('timestamp');
      }
    }
    
    if (dataModel.enums.length > 0) {
      pgTypes.add('pgEnum');
    }
    
    if (dataModel.relationships.length > 0) {
      drizzleTypes.add('relations');
    }
    
    return `import { ${Array.from(pgTypes).sort().join(', ')} } from 'drizzle-orm/pg-core';
import { ${Array.from(drizzleTypes).sort().join(', ')} } from 'drizzle-orm';
import { createInsertSchema } from 'drizzle-zod';
import { z } from 'zod';`;
  }
  
  /**
   * Generate enum definitions
   */
  private generateEnums(enums: EnumDefinition[]): string {
    if (enums.length === 0) return '';
    
    return enums.map(e => {
      const values = e.values.map(v => `'${v.value}'`).join(', ');
      return `export const ${e.name}Enum = pgEnum('${this.toSnakeCase(e.name)}', [${values}]);`;
    }).join('\n\n');
  }
  
  /**
   * Generate table definition for an entity
   */
  private generateTable(entity: EntityDefinition): string {
    const fields = entity.fields.map(f => this.generateField(f)).join(',\n  ');
    
    let timestampFields = '';
    if (entity.timestamps) {
      timestampFields = `,
  createdAt: timestamp('created_at').defaultNow().notNull(),
  updatedAt: timestamp('updated_at').defaultNow().notNull()`;
    }
    
    let softDeleteField = '';
    if (entity.softDelete) {
      softDeleteField = `,
  deletedAt: timestamp('deleted_at')`;
    }
    
    let tenantField = '';
    if (entity.tenantIsolated) {
      tenantField = `,
  tenantId: text('tenant_id').notNull()`;
    }
    
    return `// ${entity.nameAr} - ${entity.description}
export const ${this.toCamelCase(entity.tableName)} = pgTable('${entity.tableName}', {
  ${fields}${timestampFields}${softDeleteField}${tenantField}
});`;
  }
  
  /**
   * Generate field definition
   */
  private generateField(field: FieldDefinition): string {
    const pgType = this.fieldTypeToPgType(field.type);
    let definition = `${field.name}: ${this.generateFieldType(field)}`;
    
    // Add constraints
    const constraints: string[] = [];
    
    // Primary key is handled by setting the field as the first column
    // Drizzle uses .primaryKey() on the table level, not field level
    
    if (!field.nullable && field.name !== 'id') {
      constraints.push('notNull()');
    }
    
    if (field.unique && field.name !== 'id') {
      constraints.push('unique()');
    }
    
    if (field.defaultValue !== undefined) {
      if (typeof field.defaultValue === 'string') {
        constraints.push(`default('${field.defaultValue}')`);
      } else if (typeof field.defaultValue === 'boolean') {
        constraints.push(`default(${field.defaultValue})`);
      } else if (typeof field.defaultValue === 'number') {
        constraints.push(`default(${field.defaultValue})`);
      }
    }
    
    if (constraints.length > 0) {
      definition += `.${constraints.join('.')}`;
    }
    
    return definition;
  }
  
  /**
   * Generate the TypeScript type for a field
   */
  private generateFieldType(field: FieldDefinition): string {
    const columnName = this.toSnakeCase(field.name);
    
    switch (field.type) {
      case 'string':
        return `text('${columnName}')`;
      case 'text':
        return `text('${columnName}')`;
      case 'integer':
        return `integer('${columnName}')`;
      case 'bigint':
        return `bigint('${columnName}', { mode: 'number' })`;
      case 'decimal':
        return `decimal('${columnName}', { precision: 10, scale: 2 })`;
      case 'boolean':
        return `boolean('${columnName}')`;
      case 'date':
        return `date('${columnName}')`;
      case 'datetime':
      case 'timestamp':
        return `timestamp('${columnName}')`;
      case 'json':
      case 'jsonb':
        return `jsonb('${columnName}')`;
      case 'uuid':
        return `text('${columnName}')`;
      case 'array':
        return `text('${columnName}').array()`;
      case 'enum':
        return `text('${columnName}')`;
      default:
        return `text('${columnName}')`;
    }
  }
  
  /**
   * Map field type to Drizzle pg-core type
   */
  private fieldTypeToPgType(type: string): string {
    const mapping: Record<string, string> = {
      'string': 'text',
      'text': 'text',
      'integer': 'integer',
      'bigint': 'bigint',
      'decimal': 'decimal',
      'boolean': 'boolean',
      'date': 'date',
      'datetime': 'timestamp',
      'timestamp': 'timestamp',
      'json': 'jsonb',
      'jsonb': 'jsonb',
      'uuid': 'text',
      'array': 'text',
      'enum': 'text'
    };
    
    return mapping[type] || 'text';
  }
  
  /**
   * Generate types file with insert schemas
   */
  private generateTypesFile(dataModel: DataModelSpec, blueprintId: string): GeneratedFile {
    const schemas = dataModel.entities.map(e => {
      const tableName = this.toCamelCase(e.tableName);
      const entityName = e.name;
      
      return `// ${e.nameAr}
export const insert${entityName}Schema = createInsertSchema(${tableName}).omit({
  id: true,
  createdAt: true,
  updatedAt: true
});
export type Insert${entityName} = z.infer<typeof insert${entityName}Schema>;
export type ${entityName} = typeof ${tableName}.$inferSelect;`;
    }).join('\n\n');
    
    const content = `/**
 * Schema Types - Generated by Blueprint Compiler
 * Blueprint ID: ${blueprintId}
 * Generated: ${new Date().toISOString()}
 */

import { createInsertSchema } from 'drizzle-zod';
import { z } from 'zod';
import { ${dataModel.entities.map(e => this.toCamelCase(e.tableName)).join(', ')} } from './schema';

${schemas}
`;
    
    return {
      path: `generated/${blueprintId}/shared/types.ts`,
      content,
      type: 'typescript',
      checksum: this.generateChecksum(content),
      generatedAt: new Date()
    };
  }
  
  /**
   * Generate relations file
   */
  private generateRelationsFile(dataModel: DataModelSpec, blueprintId: string): GeneratedFile {
    const relationDefs = dataModel.relationships.map(r => {
      return this.generateRelation(r, dataModel.entities);
    }).join('\n\n');
    
    const content = `/**
 * Database Relations - Generated by Blueprint Compiler
 * Blueprint ID: ${blueprintId}
 * Generated: ${new Date().toISOString()}
 */

import { relations } from 'drizzle-orm';
import { ${dataModel.entities.map(e => this.toCamelCase(e.tableName)).join(', ')} } from './schema';

${relationDefs}
`;
    
    return {
      path: `generated/${blueprintId}/shared/relations.ts`,
      content,
      type: 'typescript',
      checksum: this.generateChecksum(content),
      generatedAt: new Date()
    };
  }
  
  /**
   * Generate a single relation definition
   */
  private generateRelation(rel: RelationshipDefinition, entities: EntityDefinition[]): string {
    const fromTable = this.toCamelCase(this.toSnakeCase(rel.from.entity));
    const toTable = this.toCamelCase(this.toSnakeCase(rel.to.entity));
    
    switch (rel.type) {
      case 'one-to-one':
        return `export const ${fromTable}Relations = relations(${fromTable}, ({ one }) => ({
  ${rel.to.entity.toLowerCase()}: one(${toTable}, {
    fields: [${fromTable}.${rel.from.field}],
    references: [${toTable}.${rel.to.field}]
  })
}));`;
      
      case 'one-to-many':
        return `export const ${fromTable}Relations = relations(${fromTable}, ({ many }) => ({
  ${rel.to.entity.toLowerCase()}s: many(${toTable})
}));

export const ${toTable}Relations = relations(${toTable}, ({ one }) => ({
  ${rel.from.entity.toLowerCase()}: one(${fromTable}, {
    fields: [${toTable}.${rel.to.field}],
    references: [${fromTable}.${rel.from.field}]
  })
}));`;
      
      case 'many-to-many':
        const throughTable = rel.throughTable || `${fromTable}_${toTable}`;
        return `// Many-to-many through ${throughTable}
export const ${fromTable}Relations = relations(${fromTable}, ({ many }) => ({
  ${rel.to.entity.toLowerCase()}s: many(${toTable})
}));`;
      
      default:
        return '';
    }
  }
  
  /**
   * Generate migration file
   */
  private generateMigrationFile(dataModel: DataModelSpec, blueprintId: string): GeneratedFile {
    const timestamp = new Date().toISOString().replace(/[-:T.Z]/g, '').slice(0, 14);
    const statements = dataModel.entities.map(e => this.generateCreateTable(e)).join('\n\n');
    
    const content = `-- Migration: Initial schema
-- Blueprint ID: ${blueprintId}
-- Generated: ${new Date().toISOString()}

${statements}
`;
    
    return {
      path: `generated/${blueprintId}/migrations/${timestamp}_initial_schema.sql`,
      content,
      type: 'sql',
      checksum: this.generateChecksum(content),
      generatedAt: new Date()
    };
  }
  
  /**
   * Generate CREATE TABLE SQL statement
   */
  private generateCreateTable(entity: EntityDefinition): string {
    const columns = entity.fields.map(f => {
      let sql = `  "${this.toSnakeCase(f.name)}" ${this.fieldTypeToSql(f.type)}`;
      
      if (f.name === 'id') {
        sql += ' PRIMARY KEY';
      }
      if (!f.nullable) {
        sql += ' NOT NULL';
      }
      if (f.unique && f.name !== 'id') {
        sql += ' UNIQUE';
      }
      if (f.defaultValue !== undefined) {
        if (typeof f.defaultValue === 'string') {
          sql += ` DEFAULT '${f.defaultValue}'`;
        } else {
          sql += ` DEFAULT ${f.defaultValue}`;
        }
      }
      
      return sql;
    });
    
    if (entity.timestamps) {
      columns.push('  "created_at" TIMESTAMP DEFAULT NOW() NOT NULL');
      columns.push('  "updated_at" TIMESTAMP DEFAULT NOW() NOT NULL');
    }
    
    if (entity.softDelete) {
      columns.push('  "deleted_at" TIMESTAMP');
    }
    
    if (entity.tenantIsolated) {
      columns.push('  "tenant_id" TEXT NOT NULL');
    }
    
    return `-- ${entity.nameAr}
CREATE TABLE IF NOT EXISTS "${entity.tableName}" (
${columns.join(',\n')}
);`;
  }
  
  /**
   * Map field type to SQL type
   */
  private fieldTypeToSql(type: string): string {
    const mapping: Record<string, string> = {
      'string': 'TEXT',
      'text': 'TEXT',
      'integer': 'INTEGER',
      'bigint': 'BIGINT',
      'decimal': 'DECIMAL(10,2)',
      'boolean': 'BOOLEAN',
      'date': 'DATE',
      'datetime': 'TIMESTAMP',
      'timestamp': 'TIMESTAMP',
      'json': 'JSONB',
      'jsonb': 'JSONB',
      'uuid': 'TEXT',
      'array': 'TEXT[]',
      'enum': 'TEXT'
    };
    
    return mapping[type] || 'TEXT';
  }
  
  /**
   * Convert string to camelCase
   */
  private toCamelCase(str: string): string {
    return str.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());
  }
  
  /**
   * Convert string to snake_case
   */
  private toSnakeCase(str: string): string {
    return str.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`).replace(/^_/, '');
  }
  
  /**
   * Generate simple checksum for content
   */
  private generateChecksum(content: string): string {
    let hash = 0;
    for (let i = 0; i < content.length; i++) {
      const char = content.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return Math.abs(hash).toString(16);
  }
}

export const schemaForge = new SchemaForge();
