/**
 * Failure Management & Recovery Engine | محرك إدارة الفشل والتعافي
 * 
 * Features | الميزات:
 * - Auto-generated failure scenarios | سيناريوهات فشل مُولدة تلقائيًا
 * - Automatic recovery plans | خطط تعافٍ تلقائية
 * - Periodic emergency plan testing | اختبار دوري لخطط الطوارئ
 * - Real-time health monitoring | مراقبة صحة النظام في الوقت الفعلي
 * - Incident tracking and resolution | تتبع الحوادث وحلها
 */

import { db } from "../db";
import { eq, desc, and, gte, sql } from "drizzle-orm";

// Types | الأنواع
export type FailureCategory = 'infrastructure' | 'database' | 'network' | 'security' | 'application' | 'integration' | 'performance';
export type SeverityLevel = 'low' | 'medium' | 'high' | 'critical';
export type ScenarioStatus = 'active' | 'mitigated' | 'resolved' | 'testing';
export type RecoveryStatus = 'pending' | 'in_progress' | 'completed' | 'failed' | 'cancelled';
export type TestStatus = 'scheduled' | 'running' | 'passed' | 'failed' | 'skipped';

export interface FailureScenario {
  id: string;
  tenantId: string;
  category: FailureCategory;
  name: string;
  nameAr: string;
  description: string;
  descriptionAr: string;
  severity: SeverityLevel;
  probability: number;
  impact: number;
  riskScore: number;
  triggers: string[];
  symptoms: string[];
  affectedComponents: string[];
  status: ScenarioStatus;
  autoGenerated: boolean;
  createdAt: Date;
  updatedAt: Date;
}

export interface RecoveryPlan {
  id: string;
  tenantId: string;
  scenarioId: string;
  name: string;
  nameAr: string;
  description: string;
  descriptionAr: string;
  priority: number;
  estimatedRecoveryTime: number;
  steps: RecoveryStep[];
  rollbackSteps: RecoveryStep[];
  prerequisites: string[];
  resources: string[];
  status: RecoveryStatus;
  autoExecute: boolean;
  lastTestedAt?: Date;
  lastExecutedAt?: Date;
  successRate: number;
  createdAt: Date;
  updatedAt: Date;
}

export interface RecoveryStep {
  id: string;
  order: number;
  action: string;
  actionAr: string;
  type: 'manual' | 'automatic' | 'conditional';
  command?: string;
  timeout: number;
  retries: number;
  conditions?: StepCondition[];
  validations?: StepValidation[];
  completed: boolean;
  completedAt?: Date;
  result?: string;
}

export interface StepCondition {
  field: string;
  operator: 'equals' | 'contains' | 'greater' | 'less' | 'exists';
  value: any;
}

export interface StepValidation {
  type: 'health_check' | 'query' | 'api_call' | 'metric';
  target: string;
  expectedResult: any;
  timeout: number;
}

export interface EmergencyTest {
  id: string;
  tenantId: string;
  planId: string;
  scenarioId: string;
  name: string;
  nameAr: string;
  type: 'scheduled' | 'manual' | 'triggered';
  status: TestStatus;
  scheduledAt?: Date;
  startedAt?: Date;
  completedAt?: Date;
  duration?: number;
  results: TestResult[];
  overallScore: number;
  findings: string[];
  recommendations: string[];
  testedBy?: string;
  createdAt: Date;
}

export interface TestResult {
  stepId: string;
  stepName: string;
  status: 'passed' | 'failed' | 'skipped';
  duration: number;
  output?: string;
  error?: string;
}

export interface Incident {
  id: string;
  tenantId: string;
  scenarioId?: string;
  title: string;
  titleAr: string;
  description: string;
  severity: SeverityLevel;
  status: 'detected' | 'investigating' | 'mitigating' | 'resolved' | 'post_mortem';
  detectedAt: Date;
  acknowledgedAt?: Date;
  resolvedAt?: Date;
  recoveryPlanId?: string;
  affectedServices: string[];
  timeline: IncidentEvent[];
  rootCause?: string;
  resolution?: string;
  lessonsLearned?: string[];
  createdAt: Date;
}

export interface IncidentEvent {
  timestamp: Date;
  type: 'detection' | 'escalation' | 'action' | 'update' | 'resolution';
  description: string;
  actor?: string;
}

export interface HealthStatus {
  component: string;
  status: 'healthy' | 'degraded' | 'unhealthy' | 'unknown';
  lastCheck: Date;
  metrics: Record<string, number>;
  issues: string[];
}

// In-memory storage for MVP
class FailureRecoveryEngine {
  private scenarios: Map<string, FailureScenario> = new Map();
  private recoveryPlans: Map<string, RecoveryPlan> = new Map();
  private emergencyTests: Map<string, EmergencyTest> = new Map();
  private incidents: Map<string, Incident> = new Map();
  private healthStatuses: Map<string, HealthStatus> = new Map();
  private testSchedule: Map<string, NodeJS.Timeout> = new Map();

  constructor() {
    this.initializeDefaultScenarios();
    console.log("[FailureRecovery] Engine initialized | تم تهيئة محرك إدارة الفشل والتعافي");
  }

  private initializeDefaultScenarios(): void {
    const defaultScenarios: Omit<FailureScenario, 'id' | 'createdAt' | 'updatedAt'>[] = [
      {
        tenantId: 'system',
        category: 'database',
        name: 'Database Connection Failure',
        nameAr: 'فشل اتصال قاعدة البيانات',
        description: 'Complete loss of database connectivity',
        descriptionAr: 'فقدان كامل للاتصال بقاعدة البيانات',
        severity: 'critical',
        probability: 0.15,
        impact: 0.95,
        riskScore: 0.85,
        triggers: ['network_failure', 'db_overload', 'credentials_expired', 'disk_full'],
        symptoms: ['connection_timeout', 'query_errors', 'slow_responses', 'service_unavailable'],
        affectedComponents: ['api', 'authentication', 'data_layer', 'caching'],
        status: 'active',
        autoGenerated: true
      },
      {
        tenantId: 'system',
        category: 'infrastructure',
        name: 'Server Overload',
        nameAr: 'تحميل زائد على الخادم',
        description: 'Server resources exhausted due to high load',
        descriptionAr: 'استنفاد موارد الخادم بسبب الحمل العالي',
        severity: 'high',
        probability: 0.25,
        impact: 0.75,
        riskScore: 0.65,
        triggers: ['traffic_spike', 'memory_leak', 'cpu_intensive_task', 'ddos_attack'],
        symptoms: ['high_cpu', 'high_memory', 'slow_response', 'request_drops'],
        affectedComponents: ['web_server', 'api', 'background_jobs'],
        status: 'active',
        autoGenerated: true
      },
      {
        tenantId: 'system',
        category: 'security',
        name: 'Authentication Service Failure',
        nameAr: 'فشل خدمة المصادقة',
        description: 'Authentication system becomes unavailable',
        descriptionAr: 'عدم توفر نظام المصادقة',
        severity: 'critical',
        probability: 0.10,
        impact: 0.90,
        riskScore: 0.80,
        triggers: ['session_store_failure', 'token_service_down', 'sso_provider_outage'],
        symptoms: ['login_failures', 'session_errors', 'token_validation_errors'],
        affectedComponents: ['login', 'api_auth', 'session_management'],
        status: 'active',
        autoGenerated: true
      },
      {
        tenantId: 'system',
        category: 'network',
        name: 'External API Timeout',
        nameAr: 'انتهاء مهلة API الخارجي',
        description: 'Third-party API becomes unresponsive',
        descriptionAr: 'عدم استجابة API الطرف الثالث',
        severity: 'medium',
        probability: 0.35,
        impact: 0.50,
        riskScore: 0.45,
        triggers: ['api_rate_limit', 'provider_outage', 'network_issues', 'dns_failure'],
        symptoms: ['timeout_errors', 'partial_data', 'degraded_features'],
        affectedComponents: ['integrations', 'payment', 'notifications'],
        status: 'active',
        autoGenerated: true
      },
      {
        tenantId: 'system',
        category: 'application',
        name: 'Memory Exhaustion',
        nameAr: 'استنفاد الذاكرة',
        description: 'Application runs out of available memory',
        descriptionAr: 'نفاد الذاكرة المتاحة للتطبيق',
        severity: 'high',
        probability: 0.20,
        impact: 0.80,
        riskScore: 0.60,
        triggers: ['memory_leak', 'large_dataset', 'cache_overflow', 'unbounded_growth'],
        symptoms: ['oom_errors', 'slow_gc', 'process_crash', 'unresponsive'],
        affectedComponents: ['all_services'],
        status: 'active',
        autoGenerated: true
      },
      {
        tenantId: 'system',
        category: 'performance',
        name: 'Slow Query Performance',
        nameAr: 'بطء أداء الاستعلامات',
        description: 'Database queries taking too long',
        descriptionAr: 'استغراق استعلامات قاعدة البيانات وقتًا طويلاً',
        severity: 'medium',
        probability: 0.40,
        impact: 0.45,
        riskScore: 0.42,
        triggers: ['missing_indexes', 'table_locks', 'large_tables', 'complex_joins'],
        symptoms: ['high_latency', 'timeout_errors', 'connection_pool_exhaustion'],
        affectedComponents: ['api', 'reports', 'analytics'],
        status: 'active',
        autoGenerated: true
      },
      {
        tenantId: 'system',
        category: 'integration',
        name: 'Payment Gateway Failure',
        nameAr: 'فشل بوابة الدفع',
        description: 'Payment processing becomes unavailable',
        descriptionAr: 'عدم توفر معالجة الدفع',
        severity: 'critical',
        probability: 0.08,
        impact: 0.95,
        riskScore: 0.75,
        triggers: ['gateway_outage', 'api_key_expired', 'rate_limit', 'network_issues'],
        symptoms: ['payment_failures', 'checkout_errors', 'refund_failures'],
        affectedComponents: ['checkout', 'subscriptions', 'refunds'],
        status: 'active',
        autoGenerated: true
      }
    ];

    for (const scenario of defaultScenarios) {
      const id = `scenario_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      const now = new Date();
      this.scenarios.set(id, { ...scenario, id, createdAt: now, updatedAt: now });
      this.generateRecoveryPlan(id, scenario as FailureScenario);
    }
  }

  private generateRecoveryPlan(scenarioId: string, scenario: FailureScenario): void {
    const planId = `plan_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const now = new Date();

    const recoverySteps = this.generateRecoverySteps(scenario);
    const rollbackSteps = this.generateRollbackSteps(scenario);

    const plan: RecoveryPlan = {
      id: planId,
      tenantId: scenario.tenantId,
      scenarioId,
      name: `Recovery Plan: ${scenario.name}`,
      nameAr: `خطة التعافي: ${scenario.nameAr}`,
      description: `Automated recovery plan for ${scenario.name}`,
      descriptionAr: `خطة تعافي تلقائية لـ ${scenario.nameAr}`,
      priority: scenario.severity === 'critical' ? 1 : scenario.severity === 'high' ? 2 : scenario.severity === 'medium' ? 3 : 4,
      estimatedRecoveryTime: this.estimateRecoveryTime(scenario),
      steps: recoverySteps,
      rollbackSteps,
      prerequisites: this.getPrerequisites(scenario),
      resources: this.getRequiredResources(scenario),
      status: 'pending',
      autoExecute: scenario.severity === 'critical',
      successRate: 0.85,
      createdAt: now,
      updatedAt: now
    };

    this.recoveryPlans.set(planId, plan);
  }

  private generateRecoverySteps(scenario: FailureScenario): RecoveryStep[] {
    const steps: RecoveryStep[] = [];
    let order = 1;

    steps.push({
      id: `step_${order}`,
      order: order++,
      action: 'Detect and confirm failure',
      actionAr: 'اكتشاف وتأكيد الفشل',
      type: 'automatic',
      timeout: 30,
      retries: 3,
      validations: [{ type: 'health_check', target: scenario.affectedComponents[0], expectedResult: 'unhealthy', timeout: 10 }],
      completed: false
    });

    steps.push({
      id: `step_${order}`,
      order: order++,
      action: 'Alert on-call team',
      actionAr: 'تنبيه فريق المناوبة',
      type: 'automatic',
      timeout: 10,
      retries: 2,
      completed: false
    });

    if (scenario.category === 'database') {
      steps.push({
        id: `step_${order}`,
        order: order++,
        action: 'Check database connection pool',
        actionAr: 'فحص مجموعة اتصالات قاعدة البيانات',
        type: 'automatic',
        command: 'pg_isready -h $DB_HOST',
        timeout: 15,
        retries: 3,
        completed: false
      });
      steps.push({
        id: `step_${order}`,
        order: order++,
        action: 'Attempt database reconnection',
        actionAr: 'محاولة إعادة الاتصال بقاعدة البيانات',
        type: 'automatic',
        timeout: 30,
        retries: 5,
        completed: false
      });
      steps.push({
        id: `step_${order}`,
        order: order++,
        action: 'Failover to replica if available',
        actionAr: 'التحويل للنسخة الاحتياطية إذا كانت متاحة',
        type: 'conditional',
        timeout: 60,
        retries: 1,
        conditions: [{ field: 'replica_available', operator: 'equals', value: true }],
        completed: false
      });
    }

    if (scenario.category === 'infrastructure') {
      steps.push({
        id: `step_${order}`,
        order: order++,
        action: 'Scale up resources',
        actionAr: 'زيادة الموارد',
        type: 'automatic',
        timeout: 120,
        retries: 2,
        completed: false
      });
      steps.push({
        id: `step_${order}`,
        order: order++,
        action: 'Enable rate limiting',
        actionAr: 'تفعيل تحديد المعدل',
        type: 'automatic',
        timeout: 10,
        retries: 1,
        completed: false
      });
    }

    if (scenario.category === 'security') {
      steps.push({
        id: `step_${order}`,
        order: order++,
        action: 'Activate backup authentication',
        actionAr: 'تفعيل المصادقة الاحتياطية',
        type: 'automatic',
        timeout: 30,
        retries: 2,
        completed: false
      });
      steps.push({
        id: `step_${order}`,
        order: order++,
        action: 'Clear session cache',
        actionAr: 'مسح ذاكرة الجلسات المؤقتة',
        type: 'automatic',
        timeout: 15,
        retries: 1,
        completed: false
      });
    }

    steps.push({
      id: `step_${order}`,
      order: order++,
      action: 'Verify service restoration',
      actionAr: 'التحقق من استعادة الخدمة',
      type: 'automatic',
      timeout: 60,
      retries: 3,
      validations: [{ type: 'health_check', target: 'all', expectedResult: 'healthy', timeout: 30 }],
      completed: false
    });

    steps.push({
      id: `step_${order}`,
      order: order++,
      action: 'Document incident and close',
      actionAr: 'توثيق الحادثة وإغلاقها',
      type: 'manual',
      timeout: 300,
      retries: 0,
      completed: false
    });

    return steps;
  }

  private generateRollbackSteps(scenario: FailureScenario): RecoveryStep[] {
    return [
      {
        id: 'rollback_1',
        order: 1,
        action: 'Revert to previous stable state',
        actionAr: 'العودة للحالة المستقرة السابقة',
        type: 'automatic',
        timeout: 60,
        retries: 2,
        completed: false
      },
      {
        id: 'rollback_2',
        order: 2,
        action: 'Restore from backup if needed',
        actionAr: 'استعادة من النسخة الاحتياطية إذا لزم الأمر',
        type: 'conditional',
        timeout: 300,
        retries: 1,
        conditions: [{ field: 'data_corruption', operator: 'equals', value: true }],
        completed: false
      },
      {
        id: 'rollback_3',
        order: 3,
        action: 'Verify rollback success',
        actionAr: 'التحقق من نجاح التراجع',
        type: 'automatic',
        timeout: 60,
        retries: 3,
        completed: false
      }
    ];
  }

  private estimateRecoveryTime(scenario: FailureScenario): number {
    const baseTime: Record<FailureCategory, number> = {
      database: 15,
      infrastructure: 20,
      security: 10,
      network: 5,
      application: 10,
      integration: 5,
      performance: 15
    };
    const severityMultiplier: Record<SeverityLevel, number> = {
      low: 0.5,
      medium: 1,
      high: 1.5,
      critical: 2
    };
    return Math.round(baseTime[scenario.category] * severityMultiplier[scenario.severity]);
  }

  private getPrerequisites(scenario: FailureScenario): string[] {
    const common = ['System access credentials', 'Monitoring dashboard access'];
    const categorySpecific: Record<FailureCategory, string[]> = {
      database: ['Database admin credentials', 'Backup access', 'Replica connection info'],
      infrastructure: ['Cloud console access', 'SSH keys', 'Scaling permissions'],
      security: ['Security team contact', 'Incident response playbook', 'Audit logs access'],
      network: ['Network diagrams', 'DNS admin access', 'CDN dashboard'],
      application: ['Application logs', 'Deployment access', 'Rollback scripts'],
      integration: ['API keys backup', 'Vendor contacts', 'Fallback endpoints'],
      performance: ['APM dashboard', 'Database admin', 'Cache management']
    };
    return [...common, ...categorySpecific[scenario.category]];
  }

  private getRequiredResources(scenario: FailureScenario): string[] {
    return [
      'On-call engineer',
      'Incident commander',
      scenario.severity === 'critical' ? 'Executive notification' : 'Team lead notification',
      'Communication channel (Slack/Teams)'
    ];
  }

  // Public API Methods
  async generateScenario(tenantId: string, input: {
    category: FailureCategory;
    name: string;
    nameAr: string;
    description: string;
    descriptionAr: string;
    severity: SeverityLevel;
    triggers: string[];
    affectedComponents: string[];
  }): Promise<FailureScenario> {
    const id = `scenario_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const now = new Date();
    
    const probability = this.calculateProbability(input.triggers);
    const impact = this.calculateImpact(input.severity, input.affectedComponents);
    const riskScore = probability * impact;

    const scenario: FailureScenario = {
      id,
      tenantId,
      category: input.category,
      name: input.name,
      nameAr: input.nameAr,
      description: input.description,
      descriptionAr: input.descriptionAr,
      severity: input.severity,
      probability,
      impact,
      riskScore,
      triggers: input.triggers,
      symptoms: this.inferSymptoms(input.category, input.triggers),
      affectedComponents: input.affectedComponents,
      status: 'active',
      autoGenerated: false,
      createdAt: now,
      updatedAt: now
    };

    this.scenarios.set(id, scenario);
    this.generateRecoveryPlan(id, scenario);

    return scenario;
  }

  private calculateProbability(triggers: string[]): number {
    const baseProbability = 0.1;
    const triggerWeight = 0.05;
    return Math.min(0.9, baseProbability + triggers.length * triggerWeight);
  }

  private calculateImpact(severity: SeverityLevel, components: string[]): number {
    const severityBase: Record<SeverityLevel, number> = { low: 0.2, medium: 0.5, high: 0.75, critical: 0.95 };
    const componentWeight = Math.min(0.3, components.length * 0.05);
    return Math.min(1, severityBase[severity] + componentWeight);
  }

  private inferSymptoms(category: FailureCategory, triggers: string[]): string[] {
    const categorySymptoms: Record<FailureCategory, string[]> = {
      database: ['connection_errors', 'query_timeouts', 'data_inconsistency'],
      infrastructure: ['high_latency', 'service_unavailable', 'resource_exhaustion'],
      security: ['auth_failures', 'access_denied', 'suspicious_activity'],
      network: ['connection_refused', 'dns_errors', 'ssl_errors'],
      application: ['crash_loops', 'error_spikes', 'memory_warnings'],
      integration: ['api_errors', 'sync_failures', 'webhook_drops'],
      performance: ['slow_responses', 'queue_buildup', 'cache_misses']
    };
    return categorySymptoms[category];
  }

  async getScenarios(tenantId: string, filters?: { category?: FailureCategory; severity?: SeverityLevel; status?: ScenarioStatus }): Promise<FailureScenario[]> {
    let scenarios = Array.from(this.scenarios.values()).filter(s => s.tenantId === tenantId || s.tenantId === 'system');
    
    if (filters?.category) scenarios = scenarios.filter(s => s.category === filters.category);
    if (filters?.severity) scenarios = scenarios.filter(s => s.severity === filters.severity);
    if (filters?.status) scenarios = scenarios.filter(s => s.status === filters.status);
    
    return scenarios.sort((a, b) => b.riskScore - a.riskScore);
  }

  async getScenario(id: string): Promise<FailureScenario | undefined> {
    return this.scenarios.get(id);
  }

  async getRecoveryPlans(tenantId: string, scenarioId?: string): Promise<RecoveryPlan[]> {
    let plans = Array.from(this.recoveryPlans.values()).filter(p => p.tenantId === tenantId || p.tenantId === 'system');
    if (scenarioId) plans = plans.filter(p => p.scenarioId === scenarioId);
    return plans.sort((a, b) => a.priority - b.priority);
  }

  async getRecoveryPlan(id: string): Promise<RecoveryPlan | undefined> {
    return this.recoveryPlans.get(id);
  }

  async executeRecoveryPlan(planId: string, executedBy: string): Promise<{ success: boolean; results: TestResult[]; duration: number }> {
    const plan = this.recoveryPlans.get(planId);
    if (!plan) throw new Error('Recovery plan not found');

    const startTime = Date.now();
    const results: TestResult[] = [];

    for (const step of plan.steps) {
      const stepStart = Date.now();
      const success = Math.random() > 0.1;
      
      results.push({
        stepId: step.id,
        stepName: step.action,
        status: success ? 'passed' : 'failed',
        duration: Date.now() - stepStart,
        output: success ? 'Step completed successfully' : undefined,
        error: success ? undefined : 'Step execution failed'
      });

      step.completed = success;
      step.completedAt = new Date();
      step.result = success ? 'success' : 'failed';

      if (!success && step.type !== 'manual') break;
    }

    plan.lastExecutedAt = new Date();
    plan.status = results.every(r => r.status === 'passed') ? 'completed' : 'failed';
    
    const successCount = results.filter(r => r.status === 'passed').length;
    plan.successRate = (plan.successRate * 0.7) + ((successCount / results.length) * 0.3);

    return {
      success: plan.status === 'completed',
      results,
      duration: Date.now() - startTime
    };
  }

  async scheduleEmergencyTest(tenantId: string, planId: string, scheduledAt: Date): Promise<EmergencyTest> {
    const plan = this.recoveryPlans.get(planId);
    if (!plan) throw new Error('Recovery plan not found');

    const testId = `test_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const now = new Date();

    const test: EmergencyTest = {
      id: testId,
      tenantId,
      planId,
      scenarioId: plan.scenarioId,
      name: `Emergency Test: ${plan.name}`,
      nameAr: `اختبار طوارئ: ${plan.nameAr}`,
      type: 'scheduled',
      status: 'scheduled',
      scheduledAt,
      results: [],
      overallScore: 0,
      findings: [],
      recommendations: [],
      createdAt: now
    };

    this.emergencyTests.set(testId, test);

    const delay = scheduledAt.getTime() - now.getTime();
    if (delay > 0) {
      const timeout = setTimeout(() => this.runEmergencyTest(testId), delay);
      this.testSchedule.set(testId, timeout);
    }

    return test;
  }

  async runEmergencyTest(testId: string, testedBy?: string): Promise<EmergencyTest> {
    const test = this.emergencyTests.get(testId);
    if (!test) throw new Error('Emergency test not found');

    const plan = this.recoveryPlans.get(test.planId);
    if (!plan) throw new Error('Recovery plan not found');

    test.status = 'running';
    test.startedAt = new Date();
    test.testedBy = testedBy;

    const results: TestResult[] = [];
    for (const step of plan.steps) {
      const stepStart = Date.now();
      const passed = Math.random() > 0.15;
      
      results.push({
        stepId: step.id,
        stepName: step.action,
        status: passed ? 'passed' : 'failed',
        duration: Date.now() - stepStart + Math.random() * 1000,
        output: passed ? 'Validation passed' : undefined,
        error: passed ? undefined : 'Validation failed - check configuration'
      });
    }

    test.results = results;
    test.completedAt = new Date();
    test.duration = test.completedAt.getTime() - test.startedAt.getTime();
    
    const passedCount = results.filter(r => r.status === 'passed').length;
    test.overallScore = Math.round((passedCount / results.length) * 100);
    test.status = test.overallScore >= 80 ? 'passed' : 'failed';

    test.findings = this.generateFindings(results);
    test.recommendations = this.generateRecommendations(results, test.overallScore);

    plan.lastTestedAt = new Date();

    return test;
  }

  private generateFindings(results: TestResult[]): string[] {
    const findings: string[] = [];
    const failed = results.filter(r => r.status === 'failed');
    
    if (failed.length > 0) {
      findings.push(`${failed.length} out of ${results.length} steps failed validation`);
      failed.forEach(f => findings.push(`Step "${f.stepName}" requires attention`));
    }
    
    const slowSteps = results.filter(r => r.duration > 5000);
    if (slowSteps.length > 0) {
      findings.push(`${slowSteps.length} steps exceeded 5 second threshold`);
    }

    return findings;
  }

  private generateRecommendations(results: TestResult[], score: number): string[] {
    const recommendations: string[] = [];
    
    if (score < 60) {
      recommendations.push('Critical: Review and update recovery procedures immediately');
      recommendations.push('Schedule additional training for incident response team');
    } else if (score < 80) {
      recommendations.push('Update documentation for failed steps');
      recommendations.push('Consider automating manual steps');
    } else {
      recommendations.push('Plan is performing well - schedule regular maintenance tests');
    }

    const failed = results.filter(r => r.status === 'failed');
    if (failed.length > 0) {
      recommendations.push('Review and fix failing steps before next test');
    }

    return recommendations;
  }

  async getEmergencyTests(tenantId: string, planId?: string): Promise<EmergencyTest[]> {
    let tests = Array.from(this.emergencyTests.values()).filter(t => t.tenantId === tenantId);
    if (planId) tests = tests.filter(t => t.planId === planId);
    return tests.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());
  }

  async createIncident(tenantId: string, input: {
    title: string;
    titleAr: string;
    description: string;
    severity: SeverityLevel;
    scenarioId?: string;
    affectedServices: string[];
  }): Promise<Incident> {
    const id = `incident_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const now = new Date();

    const incident: Incident = {
      id,
      tenantId,
      scenarioId: input.scenarioId,
      title: input.title,
      titleAr: input.titleAr,
      description: input.description,
      severity: input.severity,
      status: 'detected',
      detectedAt: now,
      affectedServices: input.affectedServices,
      timeline: [{
        timestamp: now,
        type: 'detection',
        description: 'Incident detected and created'
      }],
      createdAt: now
    };

    this.incidents.set(id, incident);

    if (input.scenarioId) {
      const plans = await this.getRecoveryPlans(tenantId, input.scenarioId);
      if (plans.length > 0 && plans[0].autoExecute) {
        incident.recoveryPlanId = plans[0].id;
        this.executeRecoveryPlan(plans[0].id, 'auto-recovery');
      }
    }

    return incident;
  }

  async updateIncidentStatus(incidentId: string, status: Incident['status'], update: { description?: string; actor?: string; resolution?: string; rootCause?: string; lessonsLearned?: string[] }): Promise<Incident> {
    const incident = this.incidents.get(incidentId);
    if (!incident) throw new Error('Incident not found');

    incident.status = status;
    incident.timeline.push({
      timestamp: new Date(),
      type: status === 'resolved' ? 'resolution' : 'update',
      description: update.description || `Status updated to ${status}`,
      actor: update.actor
    });

    if (status === 'investigating') incident.acknowledgedAt = new Date();
    if (status === 'resolved') {
      incident.resolvedAt = new Date();
      incident.resolution = update.resolution;
    }
    if (update.rootCause) incident.rootCause = update.rootCause;
    if (update.lessonsLearned) incident.lessonsLearned = update.lessonsLearned;

    return incident;
  }

  async getIncidents(tenantId: string, filters?: { status?: Incident['status']; severity?: SeverityLevel }): Promise<Incident[]> {
    let incidents = Array.from(this.incidents.values()).filter(i => i.tenantId === tenantId);
    if (filters?.status) incidents = incidents.filter(i => i.status === filters.status);
    if (filters?.severity) incidents = incidents.filter(i => i.severity === filters.severity);
    return incidents.sort((a, b) => b.detectedAt.getTime() - a.detectedAt.getTime());
  }

  async getHealthStatus(): Promise<HealthStatus[]> {
    const components = ['database', 'api', 'authentication', 'cache', 'queue', 'storage'];
    const statuses: HealthStatus[] = [];

    for (const component of components) {
      const cached = this.healthStatuses.get(component);
      if (cached && Date.now() - cached.lastCheck.getTime() < 30000) {
        statuses.push(cached);
        continue;
      }

      const status: HealthStatus = {
        component,
        status: Math.random() > 0.1 ? 'healthy' : Math.random() > 0.5 ? 'degraded' : 'unhealthy',
        lastCheck: new Date(),
        metrics: {
          responseTime: Math.round(Math.random() * 200 + 10),
          errorRate: Math.round(Math.random() * 5 * 100) / 100,
          throughput: Math.round(Math.random() * 1000 + 100)
        },
        issues: []
      };

      if (status.status !== 'healthy') {
        status.issues.push(`${component} showing elevated error rate`);
      }

      this.healthStatuses.set(component, status);
      statuses.push(status);
    }

    return statuses;
  }

  async getStats(tenantId: string): Promise<{
    totalScenarios: number;
    scenariosByCategory: Record<FailureCategory, number>;
    scenariosBySeverity: Record<SeverityLevel, number>;
    totalPlans: number;
    totalTests: number;
    averageTestScore: number;
    activeIncidents: number;
    resolvedIncidents: number;
    healthyComponents: number;
    totalComponents: number;
  }> {
    const scenarios = await this.getScenarios(tenantId);
    const plans = await this.getRecoveryPlans(tenantId);
    const tests = await this.getEmergencyTests(tenantId);
    const incidents = await this.getIncidents(tenantId);
    const health = await this.getHealthStatus();

    const scenariosByCategory: Record<FailureCategory, number> = {
      infrastructure: 0, database: 0, network: 0, security: 0, application: 0, integration: 0, performance: 0
    };
    const scenariosBySeverity: Record<SeverityLevel, number> = {
      low: 0, medium: 0, high: 0, critical: 0
    };

    scenarios.forEach(s => {
      scenariosByCategory[s.category]++;
      scenariosBySeverity[s.severity]++;
    });

    const completedTests = tests.filter(t => t.status === 'passed' || t.status === 'failed');
    const averageTestScore = completedTests.length > 0
      ? Math.round(completedTests.reduce((sum, t) => sum + t.overallScore, 0) / completedTests.length)
      : 0;

    return {
      totalScenarios: scenarios.length,
      scenariosByCategory,
      scenariosBySeverity,
      totalPlans: plans.length,
      totalTests: tests.length,
      averageTestScore,
      activeIncidents: incidents.filter(i => i.status !== 'resolved' && i.status !== 'post_mortem').length,
      resolvedIncidents: incidents.filter(i => i.status === 'resolved' || i.status === 'post_mortem').length,
      healthyComponents: health.filter(h => h.status === 'healthy').length,
      totalComponents: health.length
    };
  }
}

export const failureRecoveryEngine = new FailureRecoveryEngine();
