import type { Express, Request, Response, NextFunction } from "express";
import { createServer, type Server } from "http";
import { storage } from "./storage";
import { generateWebsiteCode, refineWebsiteCode } from "./anthropic";
import { insertProjectSchema, insertMessageSchema, insertProjectVersionSchema, insertShareLinkSchema, insertUserSchema, type User } from "@shared/schema";
import { z } from "zod";
import { randomBytes } from "crypto";
import bcrypt from "bcryptjs";

// Session user type
declare module 'express-session' {
  interface SessionData {
    userId?: string;
    user?: Omit<User, 'password'>;
  }
}

// Auth middleware
const requireAuth = (req: Request, res: Response, next: NextFunction) => {
  if (!req.session?.userId) {
    return res.status(401).json({ error: "يجب تسجيل الدخول أولاً / Authentication required" });
  }
  next();
};

// Admin/Sovereign middleware
const requireSovereign = (req: Request, res: Response, next: NextFunction) => {
  if (!req.session?.user || req.session.user.role !== 'sovereign') {
    return res.status(403).json({ error: "صلاحيات سيادية مطلوبة / Sovereign access required" });
  }
  next();
};

export async function registerRoutes(
  httpServer: Server,
  app: Express
): Promise<Server> {
  
  // ============ Auth Routes - INFERA نظام المصادقة ============
  
  // Register - إنشاء حساب جديد
  const registerSchema = z.object({
    email: z.string().email("البريد الإلكتروني غير صحيح"),
    username: z.string().min(3, "اسم المستخدم يجب أن يكون 3 أحرف على الأقل"),
    password: z.string().min(6, "كلمة المرور يجب أن تكون 6 أحرف على الأقل"),
    fullName: z.string().optional(),
    language: z.enum(["ar", "en"]).default("ar"),
  });

  app.post("/api/auth/register", async (req, res) => {
    try {
      const data = registerSchema.parse(req.body);
      
      // Check if user exists
      const existingUser = await storage.getUserByEmail(data.email);
      if (existingUser) {
        return res.status(400).json({ error: "البريد الإلكتروني مستخدم بالفعل / Email already exists" });
      }
      
      const existingUsername = await storage.getUserByUsername(data.username);
      if (existingUsername) {
        return res.status(400).json({ error: "اسم المستخدم مستخدم بالفعل / Username already exists" });
      }
      
      // Hash password
      const hashedPassword = await bcrypt.hash(data.password, 12);
      
      // Create user with free role
      const user = await storage.createUser({
        email: data.email,
        username: data.username,
        password: hashedPassword,
        fullName: data.fullName || null,
        language: data.language,
        role: "free",
        isActive: true,
        emailVerified: false,
      });
      
      // Set session
      const { password: _, ...userWithoutPassword } = user;
      req.session.userId = user.id;
      req.session.user = userWithoutPassword;
      
      res.status(201).json({ 
        message: "تم إنشاء الحساب بنجاح / Account created successfully",
        user: userWithoutPassword 
      });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ error: error.errors });
      }
      console.error("Registration error:", error);
      res.status(500).json({ error: "فشل في إنشاء الحساب / Failed to create account" });
    }
  });

  // Login - تسجيل الدخول
  const loginSchema = z.object({
    email: z.string().email(),
    password: z.string(),
  });

  app.post("/api/auth/login", async (req, res) => {
    try {
      const { email, password } = loginSchema.parse(req.body);
      
      const user = await storage.getUserByEmail(email);
      if (!user) {
        return res.status(401).json({ error: "بيانات الدخول غير صحيحة / Invalid credentials" });
      }
      
      if (!user.isActive) {
        return res.status(403).json({ error: "الحساب معطل / Account is disabled" });
      }
      
      const isValidPassword = await bcrypt.compare(password, user.password);
      if (!isValidPassword) {
        return res.status(401).json({ error: "بيانات الدخول غير صحيحة / Invalid credentials" });
      }
      
      // Set session
      const { password: _, ...userWithoutPassword } = user;
      req.session.userId = user.id;
      req.session.user = userWithoutPassword;
      
      res.json({ 
        message: "تم تسجيل الدخول بنجاح / Login successful",
        user: userWithoutPassword 
      });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ error: error.errors });
      }
      res.status(500).json({ error: "فشل في تسجيل الدخول / Login failed" });
    }
  });

  // Logout - تسجيل الخروج
  app.post("/api/auth/logout", (req, res) => {
    req.session.destroy((err) => {
      if (err) {
        return res.status(500).json({ error: "فشل في تسجيل الخروج / Logout failed" });
      }
      res.json({ message: "تم تسجيل الخروج بنجاح / Logout successful" });
    });
  });

  // Get current user - الحصول على المستخدم الحالي
  app.get("/api/auth/me", (req, res) => {
    if (!req.session?.userId) {
      return res.status(401).json({ error: "غير مسجل الدخول / Not logged in" });
    }
    res.json({ user: req.session.user });
  });

  // ============ Subscription Plans Routes - خطط الاشتراك ============
  
  // Get all subscription plans
  app.get("/api/plans", async (req, res) => {
    try {
      const plans = await storage.getSubscriptionPlans();
      res.json(plans);
    } catch (error) {
      res.status(500).json({ error: "فشل في جلب خطط الاشتراك" });
    }
  });

  // Get current user subscription
  app.get("/api/subscription", requireAuth, async (req, res) => {
    try {
      const subscription = await storage.getUserSubscription(req.session.userId!);
      res.json(subscription || null);
    } catch (error) {
      res.status(500).json({ error: "فشل في جلب الاشتراك" });
    }
  });

  // ============ Sovereign Routes - مسارات سيادية ============
  
  // Get all users (sovereign only)
  app.get("/api/sovereign/users", requireAuth, requireSovereign, async (req, res) => {
    try {
      const users = await storage.getAllUsers();
      res.json(users.map(u => {
        const { password: _, ...rest } = u;
        return rest;
      }));
    } catch (error) {
      res.status(500).json({ error: "فشل في جلب المستخدمين" });
    }
  });

  // Activate user subscription manually (sovereign only)
  app.post("/api/sovereign/activate-subscription", requireAuth, requireSovereign, async (req, res) => {
    try {
      const { userId, planId, billingCycle } = req.body;
      
      // Update user role based on plan
      const plan = await storage.getSubscriptionPlan(planId);
      if (!plan) {
        return res.status(404).json({ error: "الخطة غير موجودة" });
      }
      
      // Create subscription
      const now = new Date();
      const periodEnd = new Date();
      switch (billingCycle) {
        case 'monthly': periodEnd.setMonth(periodEnd.getMonth() + 1); break;
        case 'quarterly': periodEnd.setMonth(periodEnd.getMonth() + 3); break;
        case 'semi_annual': periodEnd.setMonth(periodEnd.getMonth() + 6); break;
        case 'yearly': periodEnd.setFullYear(periodEnd.getFullYear() + 1); break;
      }
      
      const subscription = await storage.createUserSubscription({
        userId,
        planId,
        status: "active",
        billingCycle,
        paymentMethod: "manual",
        currentPeriodStart: now,
        currentPeriodEnd: periodEnd,
      });
      
      // Update user role
      await storage.updateUser(userId, { role: plan.role });
      
      res.json({ message: "تم تفعيل الاشتراك بنجاح", subscription });
    } catch (error) {
      console.error("Subscription activation error:", error);
      res.status(500).json({ error: "فشل في تفعيل الاشتراك" });
    }
  });

  // ============ Projects Routes ============
  
  // Get all projects
  app.get("/api/projects", async (req, res) => {
    try {
      const projects = await storage.getProjects();
      res.json(projects);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch projects" });
    }
  });

  // Get single project
  app.get("/api/projects/:id", async (req, res) => {
    try {
      const project = await storage.getProject(req.params.id);
      if (!project) {
        return res.status(404).json({ error: "Project not found" });
      }
      res.json(project);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch project" });
    }
  });

  // Create project
  app.post("/api/projects", async (req, res) => {
    try {
      const data = insertProjectSchema.parse(req.body);
      const project = await storage.createProject(data);
      res.status(201).json(project);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ error: error.errors });
      }
      res.status(500).json({ error: "Failed to create project" });
    }
  });

  // Update project
  app.patch("/api/projects/:id", async (req, res) => {
    try {
      const data = insertProjectSchema.partial().parse(req.body);
      const project = await storage.updateProject(req.params.id, data);
      if (!project) {
        return res.status(404).json({ error: "Project not found" });
      }
      res.json(project);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ error: error.errors });
      }
      res.status(500).json({ error: "Failed to update project" });
    }
  });

  // Delete project
  app.delete("/api/projects/:id", async (req, res) => {
    try {
      const deleted = await storage.deleteProject(req.params.id);
      if (!deleted) {
        return res.status(404).json({ error: "Project not found" });
      }
      res.status(204).send();
    } catch (error) {
      res.status(500).json({ error: "Failed to delete project" });
    }
  });

  // ============ Templates Routes ============
  
  // Get all templates
  app.get("/api/templates", async (req, res) => {
    try {
      const templates = await storage.getTemplates();
      res.json(templates);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch templates" });
    }
  });

  // Get single template
  app.get("/api/templates/:id", async (req, res) => {
    try {
      const template = await storage.getTemplate(req.params.id);
      if (!template) {
        return res.status(404).json({ error: "Template not found" });
      }
      res.json(template);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch template" });
    }
  });

  // ============ Messages Routes ============
  
  // Get messages for a project
  app.get("/api/projects/:projectId/messages", async (req, res) => {
    try {
      const messages = await storage.getMessagesByProject(req.params.projectId);
      res.json(messages);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch messages" });
    }
  });

  // Create message
  app.post("/api/messages", async (req, res) => {
    try {
      const data = insertMessageSchema.parse(req.body);
      const message = await storage.createMessage(data);
      res.status(201).json(message);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ error: error.errors });
      }
      res.status(500).json({ error: "Failed to create message" });
    }
  });

  // ============ AI Generation Route ============
  
  const generateSchema = z.object({
    prompt: z.string().min(1, "Prompt is required"),
    projectId: z.string().optional().nullable(),
    context: z.string().optional(),
  });

  app.post("/api/generate", async (req, res) => {
    try {
      const { prompt, context } = generateSchema.parse(req.body);
      
      let result;
      if (context) {
        // Parse context to extract current code
        const htmlMatch = context.match(/Current HTML: ([\s\S]*?)(?=\nCurrent CSS:|$)/);
        const cssMatch = context.match(/Current CSS: ([\s\S]*?)(?=\nCurrent JS:|$)/);
        const jsMatch = context.match(/Current JS: ([\s\S]*?)$/);
        
        const currentHtml = htmlMatch?.[1]?.trim() || "";
        const currentCss = cssMatch?.[1]?.trim() || "";
        const currentJs = jsMatch?.[1]?.trim() || "";
        
        if (currentHtml || currentCss || currentJs) {
          result = await refineWebsiteCode(prompt, currentHtml, currentCss, currentJs);
        } else {
          result = await generateWebsiteCode(prompt);
        }
      } else {
        result = await generateWebsiteCode(prompt);
      }
      
      res.json(result);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ error: error.errors });
      }
      console.error("Generation error:", error);
      res.status(500).json({ 
        error: "Failed to generate code",
        message: error instanceof Error ? error.message : "Unknown error"
      });
    }
  });

  // ============ Project Versions Routes ============

  // Get all versions for a project
  app.get("/api/projects/:projectId/versions", async (req, res) => {
    try {
      const versions = await storage.getProjectVersions(req.params.projectId);
      res.json(versions);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch versions" });
    }
  });

  // Get single version
  app.get("/api/versions/:id", async (req, res) => {
    try {
      const version = await storage.getProjectVersion(req.params.id);
      if (!version) {
        return res.status(404).json({ error: "Version not found" });
      }
      res.json(version);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch version" });
    }
  });

  // Create version (save snapshot)
  app.post("/api/projects/:projectId/versions", async (req, res) => {
    try {
      const project = await storage.getProject(req.params.projectId);
      if (!project) {
        return res.status(404).json({ error: "Project not found" });
      }

      // Get existing versions to determine version number
      const existingVersions = await storage.getProjectVersions(req.params.projectId);
      const versionNumber = `v${existingVersions.length + 1}`;

      const versionData = {
        projectId: req.params.projectId,
        versionNumber,
        htmlCode: project.htmlCode,
        cssCode: project.cssCode,
        jsCode: project.jsCode,
        description: req.body.description || `Snapshot ${versionNumber}`,
      };

      const version = await storage.createProjectVersion(versionData);
      res.status(201).json(version);
    } catch (error) {
      res.status(500).json({ error: "Failed to create version" });
    }
  });

  // Restore version
  app.post("/api/projects/:projectId/restore/:versionId", async (req, res) => {
    try {
      const version = await storage.getProjectVersion(req.params.versionId);
      if (!version) {
        return res.status(404).json({ error: "Version not found" });
      }

      const project = await storage.updateProject(req.params.projectId, {
        htmlCode: version.htmlCode,
        cssCode: version.cssCode,
        jsCode: version.jsCode,
      });

      if (!project) {
        return res.status(404).json({ error: "Project not found" });
      }

      res.json(project);
    } catch (error) {
      res.status(500).json({ error: "Failed to restore version" });
    }
  });

  // ============ Share Links Routes ============

  // Get share links for a project
  app.get("/api/projects/:projectId/shares", async (req, res) => {
    try {
      const shares = await storage.getShareLinksByProject(req.params.projectId);
      res.json(shares);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch share links" });
    }
  });

  // Create share link
  app.post("/api/projects/:projectId/share", async (req, res) => {
    try {
      const project = await storage.getProject(req.params.projectId);
      if (!project) {
        return res.status(404).json({ error: "Project not found" });
      }

      const shareCode = randomBytes(8).toString("hex");
      const shareLink = await storage.createShareLink({
        projectId: req.params.projectId,
        shareCode,
        isActive: "true",
        expiresAt: req.body.expiresAt ? new Date(req.body.expiresAt) : null,
      });

      res.status(201).json(shareLink);
    } catch (error) {
      res.status(500).json({ error: "Failed to create share link" });
    }
  });

  // Get shared project by share code (public)
  app.get("/api/share/:shareCode", async (req, res) => {
    try {
      const shareLink = await storage.getShareLink(req.params.shareCode);
      if (!shareLink) {
        return res.status(404).json({ error: "Share link not found" });
      }

      if (shareLink.isActive !== "true") {
        return res.status(403).json({ error: "Share link is no longer active" });
      }

      if (shareLink.expiresAt && new Date(shareLink.expiresAt) < new Date()) {
        return res.status(403).json({ error: "Share link has expired" });
      }

      const project = await storage.getProject(shareLink.projectId);
      if (!project) {
        return res.status(404).json({ error: "Project not found" });
      }

      res.json({
        name: project.name,
        htmlCode: project.htmlCode,
        cssCode: project.cssCode,
        jsCode: project.jsCode,
      });
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch shared project" });
    }
  });

  // Deactivate share link
  app.delete("/api/shares/:id", async (req, res) => {
    try {
      const deactivated = await storage.deactivateShareLink(req.params.id);
      if (!deactivated) {
        return res.status(404).json({ error: "Share link not found" });
      }
      res.status(204).send();
    } catch (error) {
      res.status(500).json({ error: "Failed to deactivate share link" });
    }
  });

  // ============ Components Routes ============

  // Get all components
  app.get("/api/components", async (req, res) => {
    try {
      const category = req.query.category as string | undefined;
      const allComponents = category 
        ? await storage.getComponentsByCategory(category)
        : await storage.getComponents();
      res.json(allComponents);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch components" });
    }
  });

  // Get single component
  app.get("/api/components/:id", async (req, res) => {
    try {
      const component = await storage.getComponent(req.params.id);
      if (!component) {
        return res.status(404).json({ error: "Component not found" });
      }
      res.json(component);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch component" });
    }
  });

  return httpServer;
}
