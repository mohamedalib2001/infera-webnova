import type { Express } from "express";
import { createServer, type Server } from "http";
import { storage } from "./storage";
import { generateWebsiteCode, refineWebsiteCode } from "./openai";
import { insertProjectSchema, insertMessageSchema, insertProjectVersionSchema, insertShareLinkSchema } from "@shared/schema";
import { z } from "zod";
import { randomBytes } from "crypto";

export async function registerRoutes(
  httpServer: Server,
  app: Express
): Promise<Server> {
  
  // ============ Projects Routes ============
  
  // Get all projects
  app.get("/api/projects", async (req, res) => {
    try {
      const projects = await storage.getProjects();
      res.json(projects);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch projects" });
    }
  });

  // Get single project
  app.get("/api/projects/:id", async (req, res) => {
    try {
      const project = await storage.getProject(req.params.id);
      if (!project) {
        return res.status(404).json({ error: "Project not found" });
      }
      res.json(project);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch project" });
    }
  });

  // Create project
  app.post("/api/projects", async (req, res) => {
    try {
      const data = insertProjectSchema.parse(req.body);
      const project = await storage.createProject(data);
      res.status(201).json(project);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ error: error.errors });
      }
      res.status(500).json({ error: "Failed to create project" });
    }
  });

  // Update project
  app.patch("/api/projects/:id", async (req, res) => {
    try {
      const data = insertProjectSchema.partial().parse(req.body);
      const project = await storage.updateProject(req.params.id, data);
      if (!project) {
        return res.status(404).json({ error: "Project not found" });
      }
      res.json(project);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ error: error.errors });
      }
      res.status(500).json({ error: "Failed to update project" });
    }
  });

  // Delete project
  app.delete("/api/projects/:id", async (req, res) => {
    try {
      const deleted = await storage.deleteProject(req.params.id);
      if (!deleted) {
        return res.status(404).json({ error: "Project not found" });
      }
      res.status(204).send();
    } catch (error) {
      res.status(500).json({ error: "Failed to delete project" });
    }
  });

  // ============ Templates Routes ============
  
  // Get all templates
  app.get("/api/templates", async (req, res) => {
    try {
      const templates = await storage.getTemplates();
      res.json(templates);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch templates" });
    }
  });

  // Get single template
  app.get("/api/templates/:id", async (req, res) => {
    try {
      const template = await storage.getTemplate(req.params.id);
      if (!template) {
        return res.status(404).json({ error: "Template not found" });
      }
      res.json(template);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch template" });
    }
  });

  // ============ Messages Routes ============
  
  // Get messages for a project
  app.get("/api/projects/:projectId/messages", async (req, res) => {
    try {
      const messages = await storage.getMessagesByProject(req.params.projectId);
      res.json(messages);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch messages" });
    }
  });

  // Create message
  app.post("/api/messages", async (req, res) => {
    try {
      const data = insertMessageSchema.parse(req.body);
      const message = await storage.createMessage(data);
      res.status(201).json(message);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ error: error.errors });
      }
      res.status(500).json({ error: "Failed to create message" });
    }
  });

  // ============ AI Generation Route ============
  
  const generateSchema = z.object({
    prompt: z.string().min(1, "Prompt is required"),
    projectId: z.string().optional(),
    context: z.string().optional(),
  });

  app.post("/api/generate", async (req, res) => {
    try {
      const { prompt, context } = generateSchema.parse(req.body);
      
      let result;
      if (context) {
        // Parse context to extract current code
        const htmlMatch = context.match(/Current HTML: ([\s\S]*?)(?=\nCurrent CSS:|$)/);
        const cssMatch = context.match(/Current CSS: ([\s\S]*?)(?=\nCurrent JS:|$)/);
        const jsMatch = context.match(/Current JS: ([\s\S]*?)$/);
        
        const currentHtml = htmlMatch?.[1]?.trim() || "";
        const currentCss = cssMatch?.[1]?.trim() || "";
        const currentJs = jsMatch?.[1]?.trim() || "";
        
        if (currentHtml || currentCss || currentJs) {
          result = await refineWebsiteCode(prompt, currentHtml, currentCss, currentJs);
        } else {
          result = await generateWebsiteCode(prompt);
        }
      } else {
        result = await generateWebsiteCode(prompt);
      }
      
      res.json(result);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ error: error.errors });
      }
      console.error("Generation error:", error);
      res.status(500).json({ 
        error: "Failed to generate code",
        message: error instanceof Error ? error.message : "Unknown error"
      });
    }
  });

  // ============ Project Versions Routes ============

  // Get all versions for a project
  app.get("/api/projects/:projectId/versions", async (req, res) => {
    try {
      const versions = await storage.getProjectVersions(req.params.projectId);
      res.json(versions);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch versions" });
    }
  });

  // Get single version
  app.get("/api/versions/:id", async (req, res) => {
    try {
      const version = await storage.getProjectVersion(req.params.id);
      if (!version) {
        return res.status(404).json({ error: "Version not found" });
      }
      res.json(version);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch version" });
    }
  });

  // Create version (save snapshot)
  app.post("/api/projects/:projectId/versions", async (req, res) => {
    try {
      const project = await storage.getProject(req.params.projectId);
      if (!project) {
        return res.status(404).json({ error: "Project not found" });
      }

      // Get existing versions to determine version number
      const existingVersions = await storage.getProjectVersions(req.params.projectId);
      const versionNumber = `v${existingVersions.length + 1}`;

      const versionData = {
        projectId: req.params.projectId,
        versionNumber,
        htmlCode: project.htmlCode,
        cssCode: project.cssCode,
        jsCode: project.jsCode,
        description: req.body.description || `Snapshot ${versionNumber}`,
      };

      const version = await storage.createProjectVersion(versionData);
      res.status(201).json(version);
    } catch (error) {
      res.status(500).json({ error: "Failed to create version" });
    }
  });

  // Restore version
  app.post("/api/projects/:projectId/restore/:versionId", async (req, res) => {
    try {
      const version = await storage.getProjectVersion(req.params.versionId);
      if (!version) {
        return res.status(404).json({ error: "Version not found" });
      }

      const project = await storage.updateProject(req.params.projectId, {
        htmlCode: version.htmlCode,
        cssCode: version.cssCode,
        jsCode: version.jsCode,
      });

      if (!project) {
        return res.status(404).json({ error: "Project not found" });
      }

      res.json(project);
    } catch (error) {
      res.status(500).json({ error: "Failed to restore version" });
    }
  });

  // ============ Share Links Routes ============

  // Get share links for a project
  app.get("/api/projects/:projectId/shares", async (req, res) => {
    try {
      const shares = await storage.getShareLinksByProject(req.params.projectId);
      res.json(shares);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch share links" });
    }
  });

  // Create share link
  app.post("/api/projects/:projectId/share", async (req, res) => {
    try {
      const project = await storage.getProject(req.params.projectId);
      if (!project) {
        return res.status(404).json({ error: "Project not found" });
      }

      const shareCode = randomBytes(8).toString("hex");
      const shareLink = await storage.createShareLink({
        projectId: req.params.projectId,
        shareCode,
        isActive: "true",
        expiresAt: req.body.expiresAt ? new Date(req.body.expiresAt) : null,
      });

      res.status(201).json(shareLink);
    } catch (error) {
      res.status(500).json({ error: "Failed to create share link" });
    }
  });

  // Get shared project by share code (public)
  app.get("/api/share/:shareCode", async (req, res) => {
    try {
      const shareLink = await storage.getShareLink(req.params.shareCode);
      if (!shareLink) {
        return res.status(404).json({ error: "Share link not found" });
      }

      if (shareLink.isActive !== "true") {
        return res.status(403).json({ error: "Share link is no longer active" });
      }

      if (shareLink.expiresAt && new Date(shareLink.expiresAt) < new Date()) {
        return res.status(403).json({ error: "Share link has expired" });
      }

      const project = await storage.getProject(shareLink.projectId);
      if (!project) {
        return res.status(404).json({ error: "Project not found" });
      }

      res.json({
        name: project.name,
        htmlCode: project.htmlCode,
        cssCode: project.cssCode,
        jsCode: project.jsCode,
      });
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch shared project" });
    }
  });

  // Deactivate share link
  app.delete("/api/shares/:id", async (req, res) => {
    try {
      const deactivated = await storage.deactivateShareLink(req.params.id);
      if (!deactivated) {
        return res.status(404).json({ error: "Share link not found" });
      }
      res.status(204).send();
    } catch (error) {
      res.status(500).json({ error: "Failed to deactivate share link" });
    }
  });

  // ============ Components Routes ============

  // Get all components
  app.get("/api/components", async (req, res) => {
    try {
      const category = req.query.category as string | undefined;
      const allComponents = category 
        ? await storage.getComponentsByCategory(category)
        : await storage.getComponents();
      res.json(allComponents);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch components" });
    }
  });

  // Get single component
  app.get("/api/components/:id", async (req, res) => {
    try {
      const component = await storage.getComponent(req.params.id);
      if (!component) {
        return res.status(404).json({ error: "Component not found" });
      }
      res.json(component);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch component" });
    }
  });

  return httpServer;
}
