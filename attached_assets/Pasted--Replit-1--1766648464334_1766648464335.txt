Ø¥Ù†Ø´Ø§Ø¡ Ù†Ø¸Ø§Ù… Ø­ÙØ¸ ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù…Ø´ÙØ± ÙˆÙ…Ø¹Ø²ÙˆÙ„ Ø¨Ù€ Replit:

## ğŸ”’ Ù†Ø¸Ø§Ù… Ø§Ù„ØªØ´ÙÙŠØ± ÙˆØ§Ù„Ø­ÙØ¸ Ø§Ù„Ø¢Ù…Ù†

### 1. Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø¨ÙŠØ¦Ø© Ø§Ù„Ù…Ø¹Ø²ÙˆÙ„Ø©
```bash
# ÙÙŠ Replit Terminal
pip install cryptography sqlite3 schedule python-decouple
```

### 2. Ù†Ø¸Ø§Ù… Ø§Ù„ØªØ´ÙÙŠØ± Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ
```python
# crypto_system.py
from cryptography.fernet import Fernet
import os
import sqlite3
import json
from datetime import datetime

class SecureStorage:
    def __init__(self):
        self.key_file = ".encryption_key"
        self.db_file = "secure_data.db"
        self.key = self._get_or_create_key()
        self.cipher = Fernet(self.key)
        self._init_database()
    
    def _get_or_create_key(self):
        if os.path.exists(self.key_file):
            with open(self.key_file, 'rb') as f:
                return f.read()
        else:
            key = Fernet.generate_key()
            with open(self.key_file, 'wb') as f:
                f.write(key)
            return key
    
    def _init_database(self):
        conn = sqlite3.connect(self.db_file)
        cursor = conn.cursor()
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS conversations (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp TEXT,
                encrypted_data BLOB,
                session_id TEXT
            )
        ''')
        conn.commit()
        conn.close()
    
    def encrypt_data(self, data):
        json_data = json.dumps(data, ensure_ascii=False)
        return self.cipher.encrypt(json_data.encode('utf-8'))
    
    def decrypt_data(self, encrypted_data):
        decrypted = self.cipher.decrypt(encrypted_data)
        return json.loads(decrypted.decode('utf-8'))
```

### 3. Ù†Ø¸Ø§Ù… Ø§Ù„Ø­ÙØ¸ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ
```python
# auto_save.py
import schedule
import time
import threading
from datetime import datetime
import uuid

class AutoSaveSystem:
    def __init__(self, storage):
        self.storage = storage
        self.session_id = str(uuid.uuid4())
        self.conversation_buffer = []
        self.is_running = False
        
    def add_to_buffer(self, message_type, content, metadata=None):
        entry = {
            'timestamp': datetime.now().isoformat(),
            'type': message_type,
            'content': content,
            'metadata': metadata or {}
        }
        self.conversation_buffer.append(entry)
    
    def save_buffer(self):
        if not self.conversation_buffer:
            return
            
        conn = sqlite3.connect(self.storage.db_file)
        cursor = conn.cursor()
        
        for entry in self.conversation_buffer:
            encrypted_data = self.storage.encrypt_data(entry)
            cursor.execute('''
                INSERT INTO conversations (timestamp, encrypted_data, session_id)
                VALUES (?, ?, ?)
            ''', (entry['timestamp'], encrypted_data, self.session_id))
        
        conn.commit()
        conn.close()
        self.conversation_buffer.clear()
        print(f"âœ… ØªÙ… Ø­ÙØ¸ {len(self.conversation_buffer)} Ø±Ø³Ø§Ù„Ø© Ø¨Ø´ÙƒÙ„ Ù…Ø´ÙØ±")
    
    def start_auto_save(self, interval_minutes=5):
        schedule.every(interval_minutes).minutes.do(self.save_buffer)
        self.is_running = True
        
        def run_scheduler():
            while self.is_running:
                schedule.run_pending()
                time.sleep(1)
        
        threading.Thread(target=run_scheduler, daemon=True).start()
        print(f"ğŸ”„ ØªÙ… ØªØ´ØºÙŠÙ„ Ø§Ù„Ø­ÙØ¸ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ ÙƒÙ„ {interval_minutes} Ø¯Ù‚Ø§Ø¦Ù‚")
```

### 4. Ù†Ø¸Ø§Ù… Ø§Ø³ØªØ±Ø¬Ø§Ø¹ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø§Øª
```python
# retrieval_system.py
class ConversationRetrieval:
    def __init__(self, storage):
        self.storage = storage
    
    def get_session_conversations(self, session_id):
        conn = sqlite3.connect(self.storage.db_file)
        cursor = conn.cursor()
        
        cursor.execute('''
            SELECT encrypted_data FROM conversations 
            WHERE session_id = ? 
            ORDER BY timestamp
        ''', (session_id,))
        
        conversations = []
        for row in cursor.fetchall():
            decrypted_data = self.storage.decrypt_data(row[0])
            conversations.append(decrypted_data)
        
        conn.close()
        return conversations
    
    def search_conversations(self, keyword, session_id=None):
        conn = sqlite3.connect(self.storage.db_file)
        cursor = conn.cursor()
        
        if session_id:
            cursor.execute('''
                SELECT encrypted_data FROM conversations 
                WHERE session_id = ?
            ''', (session_id,))
        else:
            cursor.execute('SELECT encrypted_data FROM conversations')
        
        results = []
        for row in cursor.fetchall():
            try:
                decrypted_data = self.storage.decrypt_data(row[0])
                if keyword.lower() in decrypted_data['content'].lower():
                    results.append(decrypted_data)
            except:
                continue
        
        conn.close()
        return results
```

### 5. Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ
```python
# main.py
from crypto_system import SecureStorage
from auto_save import AutoSaveSystem
from retrieval_system import ConversationRetrieval

class SecureAI:
    def __init__(self):
        self.storage = SecureStorage()
        self.auto_save = AutoSaveSystem(self.storage)
        self.retrieval = ConversationRetrieval(self.storage)
        self.auto_save.start_auto_save(interval_minutes=2)  # Ø­ÙØ¸ ÙƒÙ„ Ø¯Ù‚ÙŠÙ‚ØªÙŠÙ†
        
    def process_message(self, user_message, ai_response):
        # Ø­ÙØ¸ Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
        self.auto_save.add_to_buffer(
            'user', 
            user_message, 
            {'source': 'human_input'}
        )
        
        # Ø­ÙØ¸ Ø±Ø¯ Ø§Ù„Ø°ÙƒÙŠ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ
        self.auto_save.add_to_buffer(
            'ai', 
            ai_response, 
            {'model': 'webnova_ai'}
        )
    
    def get_conversation_history(self):
        return self.retrieval.get_session_conversations(
            self.auto_save.session_id
        )
    
    def search_in_history(self, keyword):
        return self.retrieval.search_conversations(keyword)

# Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù†Ø¸Ø§Ù…
if __name__ == "__main__":
    secure_ai = SecureAI()
    
    # Ù…Ø­Ø§ÙƒØ§Ø© Ù…Ø­Ø§Ø¯Ø«Ø©
    while True:
        user_input = input("Ø£Ù†Øª: ")
        if user_input.lower() == 'exit':
            break
            
        # Ù‡Ù†Ø§ ÙŠÙ…ÙƒÙ† Ø±Ø¨Ø·Ù‡ Ù…Ø¹ WebNova AI
        ai_response = f"Ø±Ø¯ Ø§Ù„Ø°ÙƒÙŠ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ø¹Ù„Ù‰: {user_input}"
        
        # Ø­ÙØ¸ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø©
        secure_ai.process_message(user_input, ai_response)
        print(f"WebNova AI: {ai_response}")
```

### 6. Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Replit Ø§Ù„Ø¢Ù…Ù†Ø©
```toml
# .replit
[deployment]
run = "python main.py"

[env]
ENCRYPTION_ENABLED = "true"
AUTO_SAVE_INTERVAL = "2"

[secrets]
# Ø£Ø¶Ù Ù…ÙØ§ØªÙŠØ­ Ø§Ù„ØªØ´ÙÙŠØ± ÙÙŠ Secrets tab
```

### 7. Ù…Ù„Ù Ø§Ù„Ø¨ÙŠØ¦Ø© Ø§Ù„Ø¢Ù…Ù†Ø©
```python
# .env (Ø£Ø¶ÙÙ‡ ÙÙŠ Secrets)
ENCRYPTION_KEY_PATH=".encryption_key"
DATABASE_PATH="secure_data.db"
SESSION_TIMEOUT=3600
AUTO_SAVE_INTERVAL=120
```

## ğŸ›¡ï¸ Ø§Ù„Ø­Ù…Ø§ÙŠØ© ÙˆØ§Ù„Ø£Ù…Ø§Ù†:

1. **Ø§Ù„ØªØ´ÙÙŠØ±**: Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø´ÙØ±Ø© Ø¨Ù€ AES-256
2. **Ø§Ù„Ø¹Ø²Ù„Ø©**: Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø­Ù„ÙŠØ© ÙÙŠ Replit
3. **Ø§Ù„Ø­ÙØ¸ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ**: ÙƒÙ„ Ø¯Ù‚ÙŠÙ‚ØªÙŠÙ† Ø§ÙØªØ±Ø§Ø¶ÙŠØ§Ù‹
4. **Ù„Ø§ ØªÙˆØ¬Ø¯ Ø´Ø¨ÙƒØ© Ø®Ø§Ø±Ø¬ÙŠØ©**: ÙƒÙ„ Ø´ÙŠØ¡ Ù…Ø­Ù„ÙŠ
5. **Ù…ÙØªØ§Ø­ ÙØ±ÙŠØ¯**: Ù„ÙƒÙ„ Ù…Ø´Ø±ÙˆØ¹ Ù…ÙØªØ§Ø­ ØªØ´ÙÙŠØ± Ù…Ù†ÙØµÙ„

Ù‡Ø°Ø§ Ø§Ù„Ù†Ø¸Ø§Ù… ÙŠØ¶Ù…Ù† Ø­ÙØ¸ ÙƒØ§Ù…Ù„ Ù„Ø¬Ù…ÙŠØ¹ Ù…Ø­Ø§Ø¯Ø«Ø§ØªÙƒ ÙˆÙ…Ø´Ø§Ø±ÙŠØ¹Ùƒ Ø¨Ø´ÙƒÙ„ Ù…Ø´ÙØ± ÙˆØ¢Ù…Ù† ØªÙ…Ø§Ù…Ø§Ù‹!

